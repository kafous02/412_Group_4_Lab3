
TinyOS.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         000004a4  00800100  000006ec  00000780  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         000006ec  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          0000000f  008005a4  008005a4  00000c24  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00000c24  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00000c54  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 000000a8  00000000  00000000  00000c98  2**3
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   000013e1  00000000  00000000  00000d40  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 000009e3  00000000  00000000  00002121  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00000a06  00000000  00000000  00002b04  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000118  00000000  00000000  0000350c  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00000571  00000000  00000000  00003624  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    000000f7  00000000  00000000  00003b95  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000078  00000000  00000000  00003c8c  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 5a 00 	jmp	0xb4	; 0xb4 <__ctors_end>
   4:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
   8:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
   c:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  10:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  14:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  18:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  1c:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  20:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  24:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  28:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  2c:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  30:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  34:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  38:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  3c:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  40:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  44:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  48:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  4c:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  50:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  54:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  58:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  5c:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  60:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  64:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  68:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  6c:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  70:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  74:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  78:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  7c:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  80:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  84:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  88:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  8c:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  90:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  94:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  98:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  9c:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  a0:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  a4:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  a8:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  ac:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  b0:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>

000000b4 <__ctors_end>:
  b4:	11 24       	eor	r1, r1
  b6:	1f be       	out	0x3f, r1	; 63
  b8:	cf ef       	ldi	r28, 0xFF	; 255
  ba:	d8 e0       	ldi	r29, 0x08	; 8
  bc:	de bf       	out	0x3e, r29	; 62
  be:	cd bf       	out	0x3d, r28	; 61

000000c0 <__do_copy_data>:
  c0:	15 e0       	ldi	r17, 0x05	; 5
  c2:	a0 e0       	ldi	r26, 0x00	; 0
  c4:	b1 e0       	ldi	r27, 0x01	; 1
  c6:	ec ee       	ldi	r30, 0xEC	; 236
  c8:	f6 e0       	ldi	r31, 0x06	; 6
  ca:	02 c0       	rjmp	.+4      	; 0xd0 <UDR0+0xa>
  cc:	05 90       	lpm	r0, Z+
  ce:	0d 92       	st	X+, r0
  d0:	a4 3a       	cpi	r26, 0xA4	; 164
  d2:	b1 07       	cpc	r27, r17
  d4:	d9 f7       	brne	.-10     	; 0xcc <UDR0+0x6>

000000d6 <__do_clear_bss>:
  d6:	25 e0       	ldi	r18, 0x05	; 5
  d8:	a4 ea       	ldi	r26, 0xA4	; 164
  da:	b5 e0       	ldi	r27, 0x05	; 5
  dc:	01 c0       	rjmp	.+2      	; 0xe0 <.do_clear_bss_start>

000000de <.do_clear_bss_loop>:
  de:	1d 92       	st	X+, r1

000000e0 <.do_clear_bss_start>:
  e0:	a3 3b       	cpi	r26, 0xB3	; 179
  e2:	b2 07       	cpc	r27, r18
  e4:	e1 f7       	brne	.-8      	; 0xde <.do_clear_bss_loop>
  e6:	0e 94 45 03 	call	0x68a	; 0x68a <main>
  ea:	0c 94 74 03 	jmp	0x6e8	; 0x6e8 <_exit>

000000ee <__bad_interrupt>:
  ee:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000f2 <Mega328P_Init>:
.set	temp,0				//Sets the value of temp to 0, can be changed later

.section ".text"			//Defines a new section called .text
.global Mega328P_Init
Mega328P_Init:
		ldi	r16,0x07		;PB0(R*W),PB1(RS),PB2(E) as fixed outputs
  f2:	07 e0       	ldi	r16, 0x07	; 7
		out	DDRB,r16		//Sets all bits of Port B to outputs
  f4:	04 b9       	out	0x04, r16	; 4
		ldi	r16,0			//Zeroes the r16 register
  f6:	00 e0       	ldi	r16, 0x00	; 0
		out	PORTB,r16		//Sets all of Port B to zero
  f8:	05 b9       	out	0x05, r16	; 5
		out	U2X0,r16		;initialize UART, 8bits, no parity, 1 stop, 9600
  fa:	01 b9       	out	0x01, r16	; 1
		ldi	r17,0x0			//Loads 0x0 into r17
  fc:	10 e0       	ldi	r17, 0x00	; 0
		ldi	r16,0x67		//Loads 0x67 into r16
  fe:	07 e6       	ldi	r16, 0x67	; 103
		sts	UBRR0H,r17		//Sets high part of Baud Rate 
 100:	10 93 c5 00 	sts	0x00C5, r17	; 0x8000c5 <__TEXT_REGION_LENGTH__+0x7e00c5>
		sts	UBRR0L,r16		//Sets low part of Baud Rate
 104:	00 93 c4 00 	sts	0x00C4, r16	; 0x8000c4 <__TEXT_REGION_LENGTH__+0x7e00c4>
		ldi	r16,24			//Loads 24 into r16
 108:	08 e1       	ldi	r16, 0x18	; 24
		sts	UCSR0B,r16		//Stores r24 in the the configuration register for serial communications. Enables RX complete interrupt and TX complete interrupt
 10a:	00 93 c1 00 	sts	0x00C1, r16	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7e00c1>
		ldi	r16,6			//loads 6 into r16
 10e:	06 e0       	ldi	r16, 0x06	; 6
		sts	UCSR0C,r16		//sets characters size to 8-bits
 110:	00 93 c2 00 	sts	0x00C2, r16	; 0x8000c2 <__TEXT_REGION_LENGTH__+0x7e00c2>
		ldi r16,0x87		//initialize ADC
 114:	07 e8       	ldi	r16, 0x87	; 135
		sts	ADCSRA,r16		//stores 0x87 into ADC configuration SRAM  location
 116:	00 93 7a 00 	sts	0x007A, r16	; 0x80007a <__TEXT_REGION_LENGTH__+0x7e007a>
		ldi r16,0x40		//Loads 0x40 into r16
 11a:	00 e4       	ldi	r16, 0x40	; 64
		sts ADMUX,r16		//Stores the value of r16 into the ADC multiplexer selection memory space in SRAM
 11c:	00 93 7c 00 	sts	0x007C, r16	; 0x80007c <__TEXT_REGION_LENGTH__+0x7e007c>
		ldi r16,0			//Loads 0 into r16
 120:	00 e0       	ldi	r16, 0x00	; 0
		sts ADCSRB,r16		//Stores 0 into ADCSRB memory space which puts ADC in free roaming mode
 122:	00 93 7b 00 	sts	0x007B, r16	; 0x80007b <__TEXT_REGION_LENGTH__+0x7e007b>
		ldi r16,0xFE		//Loads 0xFE int r16
 126:	0e ef       	ldi	r16, 0xFE	; 254
		sts DIDR0,r16		//Stores 0xFE into DIDR0 which is the data input disable register
 128:	00 93 7e 00 	sts	0x007E, r16	; 0x80007e <__TEXT_REGION_LENGTH__+0x7e007e>
		ldi r16,0xFF		//student comment here
 12c:	0f ef       	ldi	r16, 0xFF	; 255
		sts DIDR1,r16		//student comment here
 12e:	00 93 7f 00 	sts	0x007F, r16	; 0x80007f <__TEXT_REGION_LENGTH__+0x7e007f>
		ret					//student comment here
 132:	08 95       	ret

00000134 <LCD_Write_Command>:
	
.global LCD_Write_Command
LCD_Write_Command:
	call	UART_Off		//student comment here
 134:	0e 94 d7 00 	call	0x1ae	; 0x1ae <UART_Off>
	ldi		r16,0xFF		;PD0 - PD7 as outputs
 138:	0f ef       	ldi	r16, 0xFF	; 255
	out		DDRD,r16		//student comment here
 13a:	0a b9       	out	0x0a, r16	; 10
	lds		r16,DATA		//student comment here
 13c:	00 91 a4 05 	lds	r16, 0x05A4	; 0x8005a4 <__data_end>
	out		PORTD,r16		//student comment here
 140:	0b b9       	out	0x0b, r16	; 11
	ldi		r16,4			//student comment here
 142:	04 e0       	ldi	r16, 0x04	; 4
	out		PORTB,r16		//student comment here
 144:	05 b9       	out	0x05, r16	; 5
	call	LCD_Delay		//student comment here
 146:	0e 94 ac 00 	call	0x158	; 0x158 <LCD_Delay>
	ldi		r16,0			//student comment here
 14a:	00 e0       	ldi	r16, 0x00	; 0
	out		PORTB,r16		//student comment here
 14c:	05 b9       	out	0x05, r16	; 5
	call	LCD_Delay		//student comment here
 14e:	0e 94 ac 00 	call	0x158	; 0x158 <LCD_Delay>
	call	UART_On			//student comment here
 152:	0e 94 d1 00 	call	0x1a2	; 0x1a2 <UART_On>
	ret						//student comment here
 156:	08 95       	ret

00000158 <LCD_Delay>:

LCD_Delay:
	ldi		r16,0xFA		//student comment here
 158:	0a ef       	ldi	r16, 0xFA	; 250

0000015a <D0>:
D0:	ldi		r17,0xFF		//student comment here
 15a:	1f ef       	ldi	r17, 0xFF	; 255

0000015c <D1>:
D1:	dec		r17				//student comment here
 15c:	1a 95       	dec	r17
	brne	D1				//student comment here
 15e:	f1 f7       	brne	.-4      	; 0x15c <D1>
	dec		r16				//student comment here
 160:	0a 95       	dec	r16
	brne	D0				//student comment here
 162:	d9 f7       	brne	.-10     	; 0x15a <D0>
	ret						//student comment here
 164:	08 95       	ret

00000166 <LCD_Write_Data>:

.global LCD_Write_Data
LCD_Write_Data:
	call	UART_Off		//student comment here
 166:	0e 94 d7 00 	call	0x1ae	; 0x1ae <UART_Off>
	ldi		r16,0xFF		//student comment here
 16a:	0f ef       	ldi	r16, 0xFF	; 255
	out		DDRD,r16		//student comment here
 16c:	0a b9       	out	0x0a, r16	; 10
	lds		r16,DATA		//student comment here
 16e:	00 91 a4 05 	lds	r16, 0x05A4	; 0x8005a4 <__data_end>
	out		PORTD,r16		//student comment here
 172:	0b b9       	out	0x0b, r16	; 11
	ldi		r16,6			//student comment here
 174:	06 e0       	ldi	r16, 0x06	; 6
	out		PORTB,r16		//student comment here
 176:	05 b9       	out	0x05, r16	; 5
	call	LCD_Delay		//student comment here
 178:	0e 94 ac 00 	call	0x158	; 0x158 <LCD_Delay>
	ldi		r16,0			//student comment here
 17c:	00 e0       	ldi	r16, 0x00	; 0
	out		PORTB,r16		//student comment here
 17e:	05 b9       	out	0x05, r16	; 5
	call	LCD_Delay		//student comment here
 180:	0e 94 ac 00 	call	0x158	; 0x158 <LCD_Delay>
	call	UART_On			//student comment here
 184:	0e 94 d1 00 	call	0x1a2	; 0x1a2 <UART_On>
	ret						//student comment here
 188:	08 95       	ret

0000018a <LCD_Read_Data>:

.global LCD_Read_Data
LCD_Read_Data:
	call	UART_Off		//student comment here
 18a:	0e 94 d7 00 	call	0x1ae	; 0x1ae <UART_Off>
	ldi		r16,0x00		//student comment here
 18e:	00 e0       	ldi	r16, 0x00	; 0
	out		DDRD,r16		//student comment here
 190:	0a b9       	out	0x0a, r16	; 10
	out		PORTB,4			//student comment here
 192:	45 b8       	out	0x05, r4	; 5
	in		r16,PORTD		//student comment here
 194:	0b b1       	in	r16, 0x0b	; 11
	sts		DATA,r16		//student comment here
 196:	00 93 a4 05 	sts	0x05A4, r16	; 0x8005a4 <__data_end>
	out		PORTB,0			//student comment here
 19a:	05 b8       	out	0x05, r0	; 5
	call	UART_On			//student comment here
 19c:	0e 94 d1 00 	call	0x1a2	; 0x1a2 <UART_On>
	ret						//student comment here
 1a0:	08 95       	ret

000001a2 <UART_On>:

.global UART_On
UART_On:
	ldi		r16,2				//student comment here
 1a2:	02 e0       	ldi	r16, 0x02	; 2
	out		DDRD,r16			//student comment here
 1a4:	0a b9       	out	0x0a, r16	; 10
	ldi		r16,24				//student comment here
 1a6:	08 e1       	ldi	r16, 0x18	; 24
	sts		UCSR0B,r16			//student comment here
 1a8:	00 93 c1 00 	sts	0x00C1, r16	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7e00c1>
	ret							//student comment here
 1ac:	08 95       	ret

000001ae <UART_Off>:

.global UART_Off
UART_Off:
	ldi	r16,0					//student comment here
 1ae:	00 e0       	ldi	r16, 0x00	; 0
	sts UCSR0B,r16				//student comment here
 1b0:	00 93 c1 00 	sts	0x00C1, r16	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7e00c1>
	ret							//student comment here
 1b4:	08 95       	ret

000001b6 <UART_Clear>:

.global UART_Clear
UART_Clear:
	lds		r16,UCSR0A			//student comment here
 1b6:	00 91 c0 00 	lds	r16, 0x00C0	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7e00c0>
	sbrs	r16,RXC0			//student comment here
 1ba:	07 ff       	sbrs	r16, 7
	ret							//student comment here
 1bc:	08 95       	ret
	lds		r16,UDR0			//student comment here
 1be:	00 91 c6 00 	lds	r16, 0x00C6	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7e00c6>
	rjmp	UART_Clear			//student comment here
 1c2:	f9 cf       	rjmp	.-14     	; 0x1b6 <UART_Clear>

000001c4 <UART_Get>:

.global UART_Get
UART_Get:
	lds		r16,UCSR0A			//student comment here
 1c4:	00 91 c0 00 	lds	r16, 0x00C0	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7e00c0>
	sbrs	r16,RXC0			//student comment here
 1c8:	07 ff       	sbrs	r16, 7
	rjmp	UART_Get			//student comment here
 1ca:	fc cf       	rjmp	.-8      	; 0x1c4 <UART_Get>
	lds		r16,UDR0			//student comment here
 1cc:	00 91 c6 00 	lds	r16, 0x00C6	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7e00c6>
	sts		ASCII,r16			//student comment here
 1d0:	00 93 a6 05 	sts	0x05A6, r16	; 0x8005a6 <ASCII>
	ret							//student comment here
 1d4:	08 95       	ret

000001d6 <UART_Put>:

.global UART_Put
UART_Put:
	lds		r17,UCSR0A			//student comment here
 1d6:	10 91 c0 00 	lds	r17, 0x00C0	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7e00c0>
	sbrs	r17,UDRE0			//student comment here
 1da:	15 ff       	sbrs	r17, 5
	rjmp	UART_Put			//student comment here
 1dc:	fc cf       	rjmp	.-8      	; 0x1d6 <UART_Put>
	lds		r16,ASCII			//student comment here
 1de:	00 91 a6 05 	lds	r16, 0x05A6	; 0x8005a6 <ASCII>
	sts		UDR0,r16			//student comment here
 1e2:	00 93 c6 00 	sts	0x00C6, r16	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7e00c6>
	ret							//student comment here
 1e6:	08 95       	ret

000001e8 <ADC_Get>:

.global ADC_Get
ADC_Get:
		ldi		r16,0xC7			//student comment here
 1e8:	07 ec       	ldi	r16, 0xC7	; 199
		sts		ADCSRA,r16			//student comment here
 1ea:	00 93 7a 00 	sts	0x007A, r16	; 0x80007a <__TEXT_REGION_LENGTH__+0x7e007a>

000001ee <A2V1>:
A2V1:	lds		r16,ADCSRA			//student comment here
 1ee:	00 91 7a 00 	lds	r16, 0x007A	; 0x80007a <__TEXT_REGION_LENGTH__+0x7e007a>
		sbrc	r16,ADSC			//student comment here
 1f2:	06 fd       	sbrc	r16, 6
		rjmp 	A2V1				//student comment here
 1f4:	fc cf       	rjmp	.-8      	; 0x1ee <A2V1>
		lds		r16,ADCL			//student comment here
 1f6:	00 91 78 00 	lds	r16, 0x0078	; 0x800078 <__TEXT_REGION_LENGTH__+0x7e0078>
		sts		LADC,r16			//student comment here
 1fa:	00 93 ae 05 	sts	0x05AE, r16	; 0x8005ae <LADC>
		lds		r16,ADCH			//student comment here
 1fe:	00 91 79 00 	lds	r16, 0x0079	; 0x800079 <__TEXT_REGION_LENGTH__+0x7e0079>
		sts		HADC,r16			//student comment here
 202:	00 93 a5 05 	sts	0x05A5, r16	; 0x8005a5 <HADC>
		ret							//student comment here
 206:	08 95       	ret

00000208 <EEPROM_Write>:

.global EEPROM_Write
EEPROM_Write:      
		sbic    EECR,EEPE
 208:	f9 99       	sbic	0x1f, 1	; 31
		rjmp    EEPROM_Write		; Wait for completion of previous write
 20a:	fe cf       	rjmp	.-4      	; 0x208 <EEPROM_Write>
		ldi		r18,0x00			; Set up address (r18:r17) in address register
 20c:	20 e0       	ldi	r18, 0x00	; 0
		ldi		r17,0x05 
 20e:	15 e0       	ldi	r17, 0x05	; 5
		ldi		r16,'F'				; Set up data in r16    
 210:	06 e4       	ldi	r16, 0x46	; 70
		out     EEARH, r18      
 212:	22 bd       	out	0x22, r18	; 34
		out     EEARL, r17			      
 214:	11 bd       	out	0x21, r17	; 33
		out     EEDR,r16			; Write data (r16) to Data Register  
 216:	00 bd       	out	0x20, r16	; 32
		sbi     EECR,EEMPE			; Write logical one to EEMPE
 218:	fa 9a       	sbi	0x1f, 2	; 31
		sbi     EECR,EEPE			; Start eeprom write by setting EEPE
 21a:	f9 9a       	sbi	0x1f, 1	; 31
		ret 
 21c:	08 95       	ret

0000021e <EEPROM_Read>:

.global EEPROM_Read
EEPROM_Read:					    
		sbic    EECR,EEPE    
 21e:	f9 99       	sbic	0x1f, 1	; 31
		rjmp    EEPROM_Read		; Wait for completion of previous write
 220:	fe cf       	rjmp	.-4      	; 0x21e <EEPROM_Read>
		ldi		r18,0x00		; Set up address (r18:r17) in EEPROM address register
 222:	20 e0       	ldi	r18, 0x00	; 0
		ldi		r17,0x05
 224:	15 e0       	ldi	r17, 0x05	; 5
		ldi		r16,0x00   
 226:	00 e0       	ldi	r16, 0x00	; 0
		out     EEARH, r18   
 228:	22 bd       	out	0x22, r18	; 34
		out     EEARL, r17		   
 22a:	11 bd       	out	0x21, r17	; 33
		sbi     EECR,EERE		; Start eeprom read by writing EERE
 22c:	f8 9a       	sbi	0x1f, 0	; 31
		in      r16,EEDR		; Read data from Data Register
 22e:	00 b5       	in	r16, 0x20	; 32
		sts		ASCII,r16  
 230:	00 93 a6 05 	sts	0x05A6, r16	; 0x8005a6 <ASCII>
		ret
 234:	08 95       	ret

00000236 <Baud4800>:
.global	Baud4800
Baud4800:
		out		U2X0, r16
 236:	01 b9       	out	0x01, r16	; 1
		ldi		r17, 0
 238:	10 e0       	ldi	r17, 0x00	; 0
		ldi		r16, 0xCF		;Value chosen based on ATmega328pb data sheet
 23a:	0f ec       	ldi	r16, 0xCF	; 207
		sts		UBRR0H, r17
 23c:	10 93 c5 00 	sts	0x00C5, r17	; 0x8000c5 <__TEXT_REGION_LENGTH__+0x7e00c5>
		sts		UBRR0L, r16
 240:	00 93 c4 00 	sts	0x00C4, r16	; 0x8000c4 <__TEXT_REGION_LENGTH__+0x7e00c4>
		ret
 244:	08 95       	ret

00000246 <Baud9600>:
.global Baud9600
Baud9600:
		out		U2X0, r16
 246:	01 b9       	out	0x01, r16	; 1
		ldi		r17, 0
 248:	10 e0       	ldi	r17, 0x00	; 0
		ldi		r16, 0x67
 24a:	07 e6       	ldi	r16, 0x67	; 103
		sts		UBRR0H, r17
 24c:	10 93 c5 00 	sts	0x00C5, r17	; 0x8000c5 <__TEXT_REGION_LENGTH__+0x7e00c5>
		sts		UBRR0L, r16
 250:	00 93 c4 00 	sts	0x00C4, r16	; 0x8000c4 <__TEXT_REGION_LENGTH__+0x7e00c4>
		ret
 254:	08 95       	ret

00000256 <Baud14400>:
.global	Baud14400
Baud14400:
		out		U2X0, r16
 256:	01 b9       	out	0x01, r16	; 1
		ldi		r17, 0
 258:	10 e0       	ldi	r17, 0x00	; 0
		ldi		r16, 0x44
 25a:	04 e4       	ldi	r16, 0x44	; 68
		sts		UBRR0H, r17
 25c:	10 93 c5 00 	sts	0x00C5, r17	; 0x8000c5 <__TEXT_REGION_LENGTH__+0x7e00c5>
		sts		UBRR0L, r16
 260:	00 93 c4 00 	sts	0x00C4, r16	; 0x8000c4 <__TEXT_REGION_LENGTH__+0x7e00c4>
		ret
 264:	08 95       	ret

00000266 <Baud19200>:
.global	Baud19200
Baud19200:
		out		U2X0, r16
 266:	01 b9       	out	0x01, r16	; 1
		ldi		r17, 0
 268:	10 e0       	ldi	r17, 0x00	; 0
		ldi		r16, 0x44
 26a:	04 e4       	ldi	r16, 0x44	; 68
		sts		UBRR0H, r17
 26c:	10 93 c5 00 	sts	0x00C5, r17	; 0x8000c5 <__TEXT_REGION_LENGTH__+0x7e00c5>
		sts		UBRR0L, r16
 270:	00 93 c4 00 	sts	0x00C4, r16	; 0x8000c4 <__TEXT_REGION_LENGTH__+0x7e00c4>
		ret
 274:	08 95       	ret

00000276 <Baud38400>:
.global Baud38400
Baud38400:
		out		U2X0, r16
 276:	01 b9       	out	0x01, r16	; 1
		ldi		r17, 0
 278:	10 e0       	ldi	r17, 0x00	; 0
		ldi		r16, 0x19
 27a:	09 e1       	ldi	r16, 0x19	; 25
		sts		UBRR0H, r17
 27c:	10 93 c5 00 	sts	0x00C5, r17	; 0x8000c5 <__TEXT_REGION_LENGTH__+0x7e00c5>
		sts		UBRR0L, r16
 280:	00 93 c4 00 	sts	0x00C4, r16	; 0x8000c4 <__TEXT_REGION_LENGTH__+0x7e00c4>
		ret
 284:	08 95       	ret

00000286 <Baud57600>:
.global	Baud57600
Baud57600:
		out		U2X0, r16
 286:	01 b9       	out	0x01, r16	; 1
		ldi		r17, 0
 288:	10 e0       	ldi	r17, 0x00	; 0
		ldi		r16, 0x10
 28a:	00 e1       	ldi	r16, 0x10	; 16
		sts		UBRR0H, r17
 28c:	10 93 c5 00 	sts	0x00C5, r17	; 0x8000c5 <__TEXT_REGION_LENGTH__+0x7e00c5>
		sts		UBRR0L, r16
 290:	00 93 c4 00 	sts	0x00C4, r16	; 0x8000c4 <__TEXT_REGION_LENGTH__+0x7e00c4>
		ret
 294:	08 95       	ret

00000296 <UART_Puts>:

char volts[5];					//string buffer for ADC output
int Acc;						//Accumulator for ADC use

void UART_Puts(const char *str)	//Display a string in the PC Terminal Program
{
 296:	cf 93       	push	r28
 298:	df 93       	push	r29
 29a:	ec 01       	movw	r28, r24
	while (*str)
 29c:	98 81       	ld	r25, Y
 29e:	99 23       	and	r25, r25
 2a0:	41 f0       	breq	.+16     	; 0x2b2 <UART_Puts+0x1c>
 2a2:	21 96       	adiw	r28, 0x01	; 1
	{
		ASCII = *str++;
 2a4:	90 93 a6 05 	sts	0x05A6, r25	; 0x8005a6 <ASCII>
		UART_Put();
 2a8:	0e 94 eb 00 	call	0x1d6	; 0x1d6 <UART_Put>
char volts[5];					//string buffer for ADC output
int Acc;						//Accumulator for ADC use

void UART_Puts(const char *str)	//Display a string in the PC Terminal Program
{
	while (*str)
 2ac:	99 91       	ld	r25, Y+
 2ae:	91 11       	cpse	r25, r1
 2b0:	f9 cf       	rjmp	.-14     	; 0x2a4 <UART_Puts+0xe>
	{
		ASCII = *str++;
		UART_Put();
	}
}
 2b2:	df 91       	pop	r29
 2b4:	cf 91       	pop	r28
 2b6:	08 95       	ret

000002b8 <LCD_Puts>:

void LCD_Puts(const char *str)	//Display a string on the LCD Module
{
 2b8:	cf 93       	push	r28
 2ba:	df 93       	push	r29
 2bc:	ec 01       	movw	r28, r24
	while (*str)
 2be:	98 81       	ld	r25, Y
 2c0:	99 23       	and	r25, r25
 2c2:	41 f0       	breq	.+16     	; 0x2d4 <LCD_Puts+0x1c>
 2c4:	21 96       	adiw	r28, 0x01	; 1
	{
		DATA = *str++;
 2c6:	90 93 a4 05 	sts	0x05A4, r25	; 0x8005a4 <__data_end>
		LCD_Write_Data();
 2ca:	0e 94 b3 00 	call	0x166	; 0x166 <LCD_Write_Data>
	}
}

void LCD_Puts(const char *str)	//Display a string on the LCD Module
{
	while (*str)
 2ce:	99 91       	ld	r25, Y+
 2d0:	91 11       	cpse	r25, r1
 2d2:	f9 cf       	rjmp	.-14     	; 0x2c6 <LCD_Puts+0xe>
	{
		DATA = *str++;
		LCD_Write_Data();
	}
}
 2d4:	df 91       	pop	r29
 2d6:	cf 91       	pop	r28
 2d8:	08 95       	ret

000002da <Banner>:


void Banner(void)				//Display Tiny OS Banner on Terminal
{
	UART_Puts(MS1);
 2da:	86 e8       	ldi	r24, 0x86	; 134
 2dc:	95 e0       	ldi	r25, 0x05	; 5
 2de:	0e 94 4b 01 	call	0x296	; 0x296 <UART_Puts>
	UART_Puts(MS2);
 2e2:	8f e4       	ldi	r24, 0x4F	; 79
 2e4:	95 e0       	ldi	r25, 0x05	; 5
 2e6:	0e 94 4b 01 	call	0x296	; 0x296 <UART_Puts>
	UART_Puts(MS4);
 2ea:	8b e1       	ldi	r24, 0x1B	; 27
 2ec:	95 e0       	ldi	r25, 0x05	; 5
 2ee:	0e 94 4b 01 	call	0x296	; 0x296 <UART_Puts>
 2f2:	08 95       	ret

000002f4 <HELP>:
}

void HELP(void)						//Display available Tiny OS Commands on Terminal
{
	UART_Puts(MS3);
 2f4:	85 e2       	ldi	r24, 0x25	; 37
 2f6:	95 e0       	ldi	r25, 0x05	; 5
 2f8:	0e 94 4b 01 	call	0x296	; 0x296 <UART_Puts>
 2fc:	08 95       	ret

000002fe <LCD>:
}

void LCD(void)						//Lite LCD demo
{
	DATA = 0x34;					//Student Comment Here
 2fe:	84 e3       	ldi	r24, 0x34	; 52
 300:	80 93 a4 05 	sts	0x05A4, r24	; 0x8005a4 <__data_end>
	LCD_Write_Command();
 304:	0e 94 9a 00 	call	0x134	; 0x134 <LCD_Write_Command>
	DATA = 0x08;					//Student Comment Here
 308:	88 e0       	ldi	r24, 0x08	; 8
 30a:	80 93 a4 05 	sts	0x05A4, r24	; 0x8005a4 <__data_end>
	LCD_Write_Command();
 30e:	0e 94 9a 00 	call	0x134	; 0x134 <LCD_Write_Command>
	DATA = 0x02;					//Student Comment Here
 312:	82 e0       	ldi	r24, 0x02	; 2
 314:	80 93 a4 05 	sts	0x05A4, r24	; 0x8005a4 <__data_end>
	LCD_Write_Command();
 318:	0e 94 9a 00 	call	0x134	; 0x134 <LCD_Write_Command>
	DATA = 0x06;					//Student Comment Here
 31c:	86 e0       	ldi	r24, 0x06	; 6
 31e:	80 93 a4 05 	sts	0x05A4, r24	; 0x8005a4 <__data_end>
	LCD_Write_Command();
 322:	0e 94 9a 00 	call	0x134	; 0x134 <LCD_Write_Command>
	DATA = 0x0f;					//Student Comment Here
 326:	8f e0       	ldi	r24, 0x0F	; 15
 328:	80 93 a4 05 	sts	0x05A4, r24	; 0x8005a4 <__data_end>
	LCD_Write_Command();
 32c:	0e 94 9a 00 	call	0x134	; 0x134 <LCD_Write_Command>
	LCD_Puts("Hello ECE412!");
 330:	80 e0       	ldi	r24, 0x00	; 0
 332:	91 e0       	ldi	r25, 0x01	; 1
 334:	0e 94 5c 01 	call	0x2b8	; 0x2b8 <LCD_Puts>
 338:	08 95       	ret

0000033a <ADC>:
	always be able to return to command line.
	*/
}

void ADC(void)						//Lite Demo of the Analog to Digital Converter
{
 33a:	cf 93       	push	r28
 33c:	df 93       	push	r29
	volts[0x1]='.';
 33e:	c9 ea       	ldi	r28, 0xA9	; 169
 340:	d5 e0       	ldi	r29, 0x05	; 5
 342:	8e e2       	ldi	r24, 0x2E	; 46
 344:	89 83       	std	Y+1, r24	; 0x01
	volts[0x3]=' ';
 346:	80 e2       	ldi	r24, 0x20	; 32
 348:	8b 83       	std	Y+3, r24	; 0x03
	volts[0x4]= 0;
 34a:	1c 82       	std	Y+4, r1	; 0x04
	ADC_Get();
 34c:	0e 94 f4 00 	call	0x1e8	; 0x1e8 <ADC_Get>
	Acc = (((int)HADC) * 0x100 + (int)(LADC))*0xA;
 350:	20 91 a5 05 	lds	r18, 0x05A5	; 0x8005a5 <HADC>
 354:	30 e0       	ldi	r19, 0x00	; 0
 356:	32 2f       	mov	r19, r18
 358:	22 27       	eor	r18, r18
 35a:	80 91 ae 05 	lds	r24, 0x05AE	; 0x8005ae <LADC>
 35e:	28 0f       	add	r18, r24
 360:	31 1d       	adc	r19, r1
 362:	c9 01       	movw	r24, r18
 364:	88 0f       	add	r24, r24
 366:	99 1f       	adc	r25, r25
 368:	22 0f       	add	r18, r18
 36a:	33 1f       	adc	r19, r19
 36c:	22 0f       	add	r18, r18
 36e:	33 1f       	adc	r19, r19
 370:	22 0f       	add	r18, r18
 372:	33 1f       	adc	r19, r19
 374:	82 0f       	add	r24, r18
 376:	93 1f       	adc	r25, r19
	volts[0x0] = 48 + (Acc / 0x7FE);
 378:	ee ef       	ldi	r30, 0xFE	; 254
 37a:	f7 e0       	ldi	r31, 0x07	; 7
 37c:	bf 01       	movw	r22, r30
 37e:	0e 94 4c 03 	call	0x698	; 0x698 <__divmodhi4>
 382:	26 2f       	mov	r18, r22
 384:	30 e3       	ldi	r19, 0x30	; 48
 386:	36 0f       	add	r19, r22
 388:	38 83       	st	Y, r19
	Acc = Acc % 0x7FE;
	volts[0x2] = ((Acc *0xA) / 0x7FE) + 48;
 38a:	ac 01       	movw	r20, r24
 38c:	44 0f       	add	r20, r20
 38e:	55 1f       	adc	r21, r21
 390:	88 0f       	add	r24, r24
 392:	99 1f       	adc	r25, r25
 394:	88 0f       	add	r24, r24
 396:	99 1f       	adc	r25, r25
 398:	88 0f       	add	r24, r24
 39a:	99 1f       	adc	r25, r25
 39c:	84 0f       	add	r24, r20
 39e:	95 1f       	adc	r25, r21
 3a0:	bf 01       	movw	r22, r30
 3a2:	0e 94 4c 03 	call	0x698	; 0x698 <__divmodhi4>
 3a6:	30 e3       	ldi	r19, 0x30	; 48
 3a8:	36 0f       	add	r19, r22
 3aa:	3a 83       	std	Y+2, r19	; 0x02
	Acc = (Acc * 0xA) % 0x7FE;
 3ac:	90 93 b0 05 	sts	0x05B0, r25	; 0x8005b0 <Acc+0x1>
 3b0:	80 93 af 05 	sts	0x05AF, r24	; 0x8005af <Acc>
	if (Acc >= 0x3FF) volts[0x2]++;
 3b4:	8f 3f       	cpi	r24, 0xFF	; 255
 3b6:	93 40       	sbci	r25, 0x03	; 3
 3b8:	1c f0       	brlt	.+6      	; 0x3c0 <ADC+0x86>
 3ba:	6f 5c       	subi	r22, 0xCF	; 207
 3bc:	60 93 ab 05 	sts	0x05AB, r22	; 0x8005ab <volts+0x2>
	if (volts[0x2] == 58)
 3c0:	80 91 ab 05 	lds	r24, 0x05AB	; 0x8005ab <volts+0x2>
 3c4:	8a 33       	cpi	r24, 0x3A	; 58
 3c6:	31 f4       	brne	.+12     	; 0x3d4 <ADC+0x9a>
	{
		volts[0x2] = 48;
 3c8:	e9 ea       	ldi	r30, 0xA9	; 169
 3ca:	f5 e0       	ldi	r31, 0x05	; 5
 3cc:	80 e3       	ldi	r24, 0x30	; 48
 3ce:	82 83       	std	Z+2, r24	; 0x02
		volts[0x0]++;
 3d0:	2f 5c       	subi	r18, 0xCF	; 207
 3d2:	20 83       	st	Z, r18
	}
	UART_Puts(volts);
 3d4:	89 ea       	ldi	r24, 0xA9	; 169
 3d6:	95 e0       	ldi	r25, 0x05	; 5
 3d8:	0e 94 4b 01 	call	0x296	; 0x296 <UART_Puts>
	UART_Puts(MS6);
 3dc:	85 ef       	ldi	r24, 0xF5	; 245
 3de:	94 e0       	ldi	r25, 0x04	; 4
 3e0:	0e 94 4b 01 	call	0x296	; 0x296 <UART_Puts>
		The potentiometer simulates a thermistor, its varying resistance simulates the
		varying resistance of a thermistor as it is heated and cooled. See the thermistor
		equations in the lab 3 folder. User must always be able to return to command line.
	*/
	
}
 3e4:	df 91       	pop	r29
 3e6:	cf 91       	pop	r28
 3e8:	08 95       	ret

000003ea <EEPROM>:

void EEPROM(void)
{
	UART_Puts("\r\nEEPROM Write and Read.");
 3ea:	8e e0       	ldi	r24, 0x0E	; 14
 3ec:	91 e0       	ldi	r25, 0x01	; 1
 3ee:	0e 94 4b 01 	call	0x296	; 0x296 <UART_Puts>
	during run-time via the command line and the same byte of data can be read back and verified after the power to
	the Xplained Mini board has been cycled. Ask the user to enter a valid EEPROM address and an
	8-bit data value. Utilize the following two given Assembly based drivers to communicate with the EEPROM. You
	may modify the EEPROM drivers as needed. User must be able to always return to command line.
	*/
	UART_Puts("\r\n");
 3f2:	87 e2       	ldi	r24, 0x27	; 39
 3f4:	91 e0       	ldi	r25, 0x01	; 1
 3f6:	0e 94 4b 01 	call	0x296	; 0x296 <UART_Puts>
	EEPROM_Write();
 3fa:	0e 94 04 01 	call	0x208	; 0x208 <EEPROM_Write>
	UART_Puts("\r\n");
 3fe:	87 e2       	ldi	r24, 0x27	; 39
 400:	91 e0       	ldi	r25, 0x01	; 1
 402:	0e 94 4b 01 	call	0x296	; 0x296 <UART_Puts>
	EEPROM_Read();
 406:	0e 94 0f 01 	call	0x21e	; 0x21e <EEPROM_Read>
	UART_Put();
 40a:	0e 94 eb 00 	call	0x1d6	; 0x1d6 <UART_Put>
	UART_Puts("\r\n");
 40e:	87 e2       	ldi	r24, 0x27	; 39
 410:	91 e0       	ldi	r25, 0x01	; 1
 412:	0e 94 4b 01 	call	0x296	; 0x296 <UART_Puts>
 416:	08 95       	ret

00000418 <ChangeBaud>:
	ChangeStopBits();
}

void ChangeBaud(void)
{
	UART_Puts("\nWhat Baud Rate would you like?\n");
 418:	8a e2       	ldi	r24, 0x2A	; 42
 41a:	91 e0       	ldi	r25, 0x01	; 1
 41c:	0e 94 4b 01 	call	0x296	; 0x296 <UART_Puts>
	UART_Puts("(1)4800\n(2)9600\n(3)14400\n(4)19200\n(5)38400\n(6)57600");
 420:	8b e4       	ldi	r24, 0x4B	; 75
 422:	91 e0       	ldi	r25, 0x01	; 1
 424:	0e 94 4b 01 	call	0x296	; 0x296 <UART_Puts>
	ASCII = '\0';
 428:	10 92 a6 05 	sts	0x05A6, r1	; 0x8005a6 <ASCII>
	while(ASCII == '\0')
	{
		UART_Get();
 42c:	0e 94 e2 00 	call	0x1c4	; 0x1c4 <UART_Get>
void ChangeBaud(void)
{
	UART_Puts("\nWhat Baud Rate would you like?\n");
	UART_Puts("(1)4800\n(2)9600\n(3)14400\n(4)19200\n(5)38400\n(6)57600");
	ASCII = '\0';
	while(ASCII == '\0')
 430:	80 91 a6 05 	lds	r24, 0x05A6	; 0x8005a6 <ASCII>
 434:	88 23       	and	r24, r24
 436:	d1 f3       	breq	.-12     	; 0x42c <ChangeBaud+0x14>
	{
		UART_Get();
	}
	switch(ASCII)
 438:	83 33       	cpi	r24, 0x33	; 51
 43a:	d1 f0       	breq	.+52     	; 0x470 <ChangeBaud+0x58>
 43c:	28 f4       	brcc	.+10     	; 0x448 <ChangeBaud+0x30>
 43e:	81 33       	cpi	r24, 0x31	; 49
 440:	49 f0       	breq	.+18     	; 0x454 <ChangeBaud+0x3c>
 442:	82 33       	cpi	r24, 0x32	; 50
 444:	71 f0       	breq	.+28     	; 0x462 <ChangeBaud+0x4a>
 446:	30 c0       	rjmp	.+96     	; 0x4a8 <ChangeBaud+0x90>
 448:	85 33       	cpi	r24, 0x35	; 53
 44a:	01 f1       	breq	.+64     	; 0x48c <ChangeBaud+0x74>
 44c:	c0 f0       	brcs	.+48     	; 0x47e <ChangeBaud+0x66>
 44e:	86 33       	cpi	r24, 0x36	; 54
 450:	21 f1       	breq	.+72     	; 0x49a <ChangeBaud+0x82>
 452:	2a c0       	rjmp	.+84     	; 0x4a8 <ChangeBaud+0x90>
	{
		case '1':
			UART_Puts("\nBaud rate successfully changed to 4800");
 454:	8f e7       	ldi	r24, 0x7F	; 127
 456:	91 e0       	ldi	r25, 0x01	; 1
 458:	0e 94 4b 01 	call	0x296	; 0x296 <UART_Puts>
			Baud4800();
 45c:	0e 94 1b 01 	call	0x236	; 0x236 <Baud4800>
		break;
 460:	08 95       	ret
		case '2':
			UART_Puts("\nBaud rate successfully changed to 9600");
 462:	87 ea       	ldi	r24, 0xA7	; 167
 464:	91 e0       	ldi	r25, 0x01	; 1
 466:	0e 94 4b 01 	call	0x296	; 0x296 <UART_Puts>
			Baud9600();
 46a:	0e 94 23 01 	call	0x246	; 0x246 <Baud9600>
		break;
 46e:	08 95       	ret
		case '3':
			UART_Puts("\nBaud rate successfully changed to 14400");
 470:	8f ec       	ldi	r24, 0xCF	; 207
 472:	91 e0       	ldi	r25, 0x01	; 1
 474:	0e 94 4b 01 	call	0x296	; 0x296 <UART_Puts>
			Baud14400();
 478:	0e 94 2b 01 	call	0x256	; 0x256 <Baud14400>
		break;
 47c:	08 95       	ret
		case '4':
			UART_Puts("\nBaud rate successfully changed to 19200");
 47e:	88 ef       	ldi	r24, 0xF8	; 248
 480:	91 e0       	ldi	r25, 0x01	; 1
 482:	0e 94 4b 01 	call	0x296	; 0x296 <UART_Puts>
			Baud19200();
 486:	0e 94 33 01 	call	0x266	; 0x266 <Baud19200>
		break;
 48a:	08 95       	ret
		case '5':
			UART_Puts("\nBaud rate successfully changed to 38400");
 48c:	81 e2       	ldi	r24, 0x21	; 33
 48e:	92 e0       	ldi	r25, 0x02	; 2
 490:	0e 94 4b 01 	call	0x296	; 0x296 <UART_Puts>
			Baud38400();
 494:	0e 94 3b 01 	call	0x276	; 0x276 <Baud38400>
		break;
 498:	08 95       	ret
		case '6':
			UART_Puts("\nBaud rate successfully changed to 57600");
 49a:	8a e4       	ldi	r24, 0x4A	; 74
 49c:	92 e0       	ldi	r25, 0x02	; 2
 49e:	0e 94 4b 01 	call	0x296	; 0x296 <UART_Puts>
			Baud57600();
 4a2:	0e 94 43 01 	call	0x286	; 0x286 <Baud57600>
		break;
 4a6:	08 95       	ret
		default:
		UART_Puts(MS5);
 4a8:	8c ef       	ldi	r24, 0xFC	; 252
 4aa:	94 e0       	ldi	r25, 0x04	; 4
 4ac:	0e 94 4b 01 	call	0x296	; 0x296 <UART_Puts>
 4b0:	08 95       	ret

000004b2 <ChangeDataBits>:
	}
}

void ChangeDataBits(void)
{
	UART_Puts("\nHow many data bits are desired? (5,6,7,8,9)");
 4b2:	83 e7       	ldi	r24, 0x73	; 115
 4b4:	92 e0       	ldi	r25, 0x02	; 2
 4b6:	0e 94 4b 01 	call	0x296	; 0x296 <UART_Puts>
	ASCII = '\0';
 4ba:	10 92 a6 05 	sts	0x05A6, r1	; 0x8005a6 <ASCII>
	while(ASCII == '\0')
	{
		UART_Get();
 4be:	0e 94 e2 00 	call	0x1c4	; 0x1c4 <UART_Get>

void ChangeDataBits(void)
{
	UART_Puts("\nHow many data bits are desired? (5,6,7,8,9)");
	ASCII = '\0';
	while(ASCII == '\0')
 4c2:	80 91 a6 05 	lds	r24, 0x05A6	; 0x8005a6 <ASCII>
 4c6:	88 23       	and	r24, r24
 4c8:	d1 f3       	breq	.-12     	; 0x4be <ChangeDataBits+0xc>
	{
		UART_Get();
	}
	switch(ASCII)
 4ca:	87 33       	cpi	r24, 0x37	; 55
 4cc:	a9 f0       	breq	.+42     	; 0x4f8 <ChangeDataBits+0x46>
 4ce:	28 f4       	brcc	.+10     	; 0x4da <ChangeDataBits+0x28>
 4d0:	85 33       	cpi	r24, 0x35	; 53
 4d2:	41 f0       	breq	.+16     	; 0x4e4 <ChangeDataBits+0x32>
 4d4:	86 33       	cpi	r24, 0x36	; 54
 4d6:	59 f0       	breq	.+22     	; 0x4ee <ChangeDataBits+0x3c>
 4d8:	39 c0       	rjmp	.+114    	; 0x54c <ChangeDataBits+0x9a>
 4da:	88 33       	cpi	r24, 0x38	; 56
 4dc:	91 f0       	breq	.+36     	; 0x502 <ChangeDataBits+0x50>
 4de:	89 33       	cpi	r24, 0x39	; 57
 4e0:	f1 f0       	breq	.+60     	; 0x51e <ChangeDataBits+0x6c>
 4e2:	34 c0       	rjmp	.+104    	; 0x54c <ChangeDataBits+0x9a>
	{
		case '5':
			UCSR0C |= (0<<1)&&(0<<2);
			UCSR0B |= (0<<2);
			UART_Puts("\nNumber of data bits has been changed to 5");
 4e4:	80 ea       	ldi	r24, 0xA0	; 160
 4e6:	92 e0       	ldi	r25, 0x02	; 2
 4e8:	0e 94 4b 01 	call	0x296	; 0x296 <UART_Puts>
		break;
 4ec:	08 95       	ret
		case '6':
			UCSR0C |= (1<<1)&&(0<<2);
			UCSR0B |= (0<<2);
			UART_Puts("\nNumber of data bits has been changed to 6");
 4ee:	8b ec       	ldi	r24, 0xCB	; 203
 4f0:	92 e0       	ldi	r25, 0x02	; 2
 4f2:	0e 94 4b 01 	call	0x296	; 0x296 <UART_Puts>
		break;
 4f6:	08 95       	ret
		case '7':
			UCSR0C |= (0<<1)&&(1<<2);
			UCSR0B |= (0<<2);
			UART_Puts("\nNumber of data bits has been changed to 7");
 4f8:	86 ef       	ldi	r24, 0xF6	; 246
 4fa:	92 e0       	ldi	r25, 0x02	; 2
 4fc:	0e 94 4b 01 	call	0x296	; 0x296 <UART_Puts>
		break;
 500:	08 95       	ret
		case '8':
			UCSR0C |= (1<<1)&&(1<<2);
 502:	80 91 a7 05 	lds	r24, 0x05A7	; 0x8005a7 <UCSR0C>
 506:	90 91 a8 05 	lds	r25, 0x05A8	; 0x8005a8 <UCSR0C+0x1>
 50a:	81 60       	ori	r24, 0x01	; 1
 50c:	90 93 a8 05 	sts	0x05A8, r25	; 0x8005a8 <UCSR0C+0x1>
 510:	80 93 a7 05 	sts	0x05A7, r24	; 0x8005a7 <UCSR0C>
			UCSR0B |= (0<<2);
			UART_Puts("\nNumber of data bits has been changed to 8");
 514:	81 e2       	ldi	r24, 0x21	; 33
 516:	93 e0       	ldi	r25, 0x03	; 3
 518:	0e 94 4b 01 	call	0x296	; 0x296 <UART_Puts>
		break;
 51c:	08 95       	ret
		case '9':
			UCSR0C |= (1<<1)&&(1<<2);
 51e:	80 91 a7 05 	lds	r24, 0x05A7	; 0x8005a7 <UCSR0C>
 522:	90 91 a8 05 	lds	r25, 0x05A8	; 0x8005a8 <UCSR0C+0x1>
 526:	81 60       	ori	r24, 0x01	; 1
 528:	90 93 a8 05 	sts	0x05A8, r25	; 0x8005a8 <UCSR0C+0x1>
 52c:	80 93 a7 05 	sts	0x05A7, r24	; 0x8005a7 <UCSR0C>
			UCSR0B |= (1<<2);
 530:	80 91 b1 05 	lds	r24, 0x05B1	; 0x8005b1 <UCSR0B>
 534:	90 91 b2 05 	lds	r25, 0x05B2	; 0x8005b2 <UCSR0B+0x1>
 538:	84 60       	ori	r24, 0x04	; 4
 53a:	90 93 b2 05 	sts	0x05B2, r25	; 0x8005b2 <UCSR0B+0x1>
 53e:	80 93 b1 05 	sts	0x05B1, r24	; 0x8005b1 <UCSR0B>
			UART_Puts("\nNumber of data bits has been changed to 9");
 542:	8c e4       	ldi	r24, 0x4C	; 76
 544:	93 e0       	ldi	r25, 0x03	; 3
 546:	0e 94 4b 01 	call	0x296	; 0x296 <UART_Puts>
		break;
 54a:	08 95       	ret
		default:
			UART_Puts(MS5);
 54c:	8c ef       	ldi	r24, 0xFC	; 252
 54e:	94 e0       	ldi	r25, 0x04	; 4
 550:	0e 94 4b 01 	call	0x296	; 0x296 <UART_Puts>
 554:	08 95       	ret

00000556 <ChangeParity>:
	}
}

void ChangeParity(void)
{
	UART_Puts("\nSelect a parity:\n(1)None\n(2)Odd\n(3)Even");
 556:	87 e7       	ldi	r24, 0x77	; 119
 558:	93 e0       	ldi	r25, 0x03	; 3
 55a:	0e 94 4b 01 	call	0x296	; 0x296 <UART_Puts>
	ASCII = '\0';
 55e:	10 92 a6 05 	sts	0x05A6, r1	; 0x8005a6 <ASCII>
	while(ASCII == '\0')
	{
		UART_Get();
 562:	0e 94 e2 00 	call	0x1c4	; 0x1c4 <UART_Get>

void ChangeParity(void)
{
	UART_Puts("\nSelect a parity:\n(1)None\n(2)Odd\n(3)Even");
	ASCII = '\0';
	while(ASCII == '\0')
 566:	80 91 a6 05 	lds	r24, 0x05A6	; 0x8005a6 <ASCII>
 56a:	88 23       	and	r24, r24
 56c:	d1 f3       	breq	.-12     	; 0x562 <ChangeParity+0xc>
	{
		UART_Get();
	}
	switch(ASCII)
 56e:	82 33       	cpi	r24, 0x32	; 50
 570:	49 f0       	breq	.+18     	; 0x584 <ChangeParity+0x2e>
 572:	83 33       	cpi	r24, 0x33	; 51
 574:	a9 f0       	breq	.+42     	; 0x5a0 <ChangeParity+0x4a>
 576:	81 33       	cpi	r24, 0x31	; 49
 578:	c1 f4       	brne	.+48     	; 0x5aa <ChangeParity+0x54>
	{
		case '1':
			UCSR0C |= (0<<5)&&(0<<4);
			UART_Puts("\nNo parity was set");
 57a:	80 ea       	ldi	r24, 0xA0	; 160
 57c:	93 e0       	ldi	r25, 0x03	; 3
 57e:	0e 94 4b 01 	call	0x296	; 0x296 <UART_Puts>
		break;
 582:	08 95       	ret
		case '2':
			UCSR0C |= (1<<5)&&(1<<4);
 584:	80 91 a7 05 	lds	r24, 0x05A7	; 0x8005a7 <UCSR0C>
 588:	90 91 a8 05 	lds	r25, 0x05A8	; 0x8005a8 <UCSR0C+0x1>
 58c:	81 60       	ori	r24, 0x01	; 1
 58e:	90 93 a8 05 	sts	0x05A8, r25	; 0x8005a8 <UCSR0C+0x1>
 592:	80 93 a7 05 	sts	0x05A7, r24	; 0x8005a7 <UCSR0C>
			UART_Puts("\nAn odd parity was set");
 596:	83 eb       	ldi	r24, 0xB3	; 179
 598:	93 e0       	ldi	r25, 0x03	; 3
 59a:	0e 94 4b 01 	call	0x296	; 0x296 <UART_Puts>
		break;
 59e:	08 95       	ret
		case '3':
			UCSR0C |= (1<<5)&&(0<<4);
			UART_Puts("\nAn even parity was set");
 5a0:	8a ec       	ldi	r24, 0xCA	; 202
 5a2:	93 e0       	ldi	r25, 0x03	; 3
 5a4:	0e 94 4b 01 	call	0x296	; 0x296 <UART_Puts>
		break;
 5a8:	08 95       	ret
		default:
			UART_Puts(MS5);
 5aa:	8c ef       	ldi	r24, 0xFC	; 252
 5ac:	94 e0       	ldi	r25, 0x04	; 4
 5ae:	0e 94 4b 01 	call	0x296	; 0x296 <UART_Puts>
 5b2:	08 95       	ret

000005b4 <ChangeStopBits>:
	}
}

void ChangeStopBits(void)
{
	UART_Puts("\nSelect how many stop bits are desired: 1 or 2");
 5b4:	82 ee       	ldi	r24, 0xE2	; 226
 5b6:	93 e0       	ldi	r25, 0x03	; 3
 5b8:	0e 94 4b 01 	call	0x296	; 0x296 <UART_Puts>
	ASCII = '\0';
 5bc:	10 92 a6 05 	sts	0x05A6, r1	; 0x8005a6 <ASCII>
	while(ASCII == '\0')
	{
		UART_Get();
 5c0:	0e 94 e2 00 	call	0x1c4	; 0x1c4 <UART_Get>

void ChangeStopBits(void)
{
	UART_Puts("\nSelect how many stop bits are desired: 1 or 2");
	ASCII = '\0';
	while(ASCII == '\0')
 5c4:	80 91 a6 05 	lds	r24, 0x05A6	; 0x8005a6 <ASCII>
 5c8:	88 23       	and	r24, r24
 5ca:	d1 f3       	breq	.-12     	; 0x5c0 <ChangeStopBits+0xc>
	{
		UART_Get();
	}
	switch(ASCII)
 5cc:	81 33       	cpi	r24, 0x31	; 49
 5ce:	19 f0       	breq	.+6      	; 0x5d6 <ChangeStopBits+0x22>
 5d0:	82 33       	cpi	r24, 0x32	; 50
 5d2:	79 f0       	breq	.+30     	; 0x5f2 <ChangeStopBits+0x3e>
 5d4:	13 c0       	rjmp	.+38     	; 0x5fc <ChangeStopBits+0x48>
	{
		case '1':
			UCSR0C |= (1<<3);
 5d6:	80 91 a7 05 	lds	r24, 0x05A7	; 0x8005a7 <UCSR0C>
 5da:	90 91 a8 05 	lds	r25, 0x05A8	; 0x8005a8 <UCSR0C+0x1>
 5de:	88 60       	ori	r24, 0x08	; 8
 5e0:	90 93 a8 05 	sts	0x05A8, r25	; 0x8005a8 <UCSR0C+0x1>
 5e4:	80 93 a7 05 	sts	0x05A7, r24	; 0x8005a7 <UCSR0C>
			UART_Puts("\nOne stop bit will be provided");
 5e8:	81 e1       	ldi	r24, 0x11	; 17
 5ea:	94 e0       	ldi	r25, 0x04	; 4
 5ec:	0e 94 4b 01 	call	0x296	; 0x296 <UART_Puts>
		break;
 5f0:	08 95       	ret
		case '2':
			UCSR0C |= (0<<3);
			UART_Puts("\nTwo stop bits will be provided");
 5f2:	80 e3       	ldi	r24, 0x30	; 48
 5f4:	94 e0       	ldi	r25, 0x04	; 4
 5f6:	0e 94 4b 01 	call	0x296	; 0x296 <UART_Puts>
		break;
 5fa:	08 95       	ret
		default:
			UART_Puts(MS5);
 5fc:	8c ef       	ldi	r24, 0xFC	; 252
 5fe:	94 e0       	ldi	r25, 0x04	; 4
 600:	0e 94 4b 01 	call	0x296	; 0x296 <UART_Puts>
 604:	08 95       	ret

00000606 <USART>:
	UART_Puts("\r\n");
}

void USART(void)
{
	UART_Puts(MS7);
 606:	80 ed       	ldi	r24, 0xD0	; 208
 608:	94 e0       	ldi	r25, 0x04	; 4
 60a:	0e 94 4b 01 	call	0x296	; 0x296 <UART_Puts>
	ChangeBaud();
 60e:	0e 94 0c 02 	call	0x418	; 0x418 <ChangeBaud>
	UART_Puts(MS8);
 612:	81 ea       	ldi	r24, 0xA1	; 161
 614:	94 e0       	ldi	r25, 0x04	; 4
 616:	0e 94 4b 01 	call	0x296	; 0x296 <UART_Puts>
	ChangeDataBits();
 61a:	0e 94 59 02 	call	0x4b2	; 0x4b2 <ChangeDataBits>
	UART_Puts(MS9);
 61e:	8f e7       	ldi	r24, 0x7F	; 127
 620:	94 e0       	ldi	r25, 0x04	; 4
 622:	0e 94 4b 01 	call	0x296	; 0x296 <UART_Puts>
	ChangeParity();
 626:	0e 94 ab 02 	call	0x556	; 0x556 <ChangeParity>
	UART_Puts(MS10);
 62a:	80 e5       	ldi	r24, 0x50	; 80
 62c:	94 e0       	ldi	r25, 0x04	; 4
 62e:	0e 94 4b 01 	call	0x296	; 0x296 <UART_Puts>
	ChangeStopBits();
 632:	0e 94 da 02 	call	0x5b4	; 0x5b4 <ChangeStopBits>
 636:	08 95       	ret

00000638 <Command>:
}


void Command(void)					//command interpreter
{
	UART_Puts(MS3);
 638:	85 e2       	ldi	r24, 0x25	; 37
 63a:	95 e0       	ldi	r25, 0x05	; 5
 63c:	0e 94 4b 01 	call	0x296	; 0x296 <UART_Puts>
	ASCII = '\0';						
 640:	10 92 a6 05 	sts	0x05A6, r1	; 0x8005a6 <ASCII>
	while (ASCII == '\0')
	{
		UART_Get();
 644:	0e 94 e2 00 	call	0x1c4	; 0x1c4 <UART_Get>

void Command(void)					//command interpreter
{
	UART_Puts(MS3);
	ASCII = '\0';						
	while (ASCII == '\0')
 648:	80 91 a6 05 	lds	r24, 0x05A6	; 0x8005a6 <ASCII>
 64c:	88 23       	and	r24, r24
 64e:	d1 f3       	breq	.-12     	; 0x644 <Command+0xc>
	{
		UART_Get();
	}
	switch (ASCII)
 650:	85 36       	cpi	r24, 0x65	; 101
 652:	79 f0       	breq	.+30     	; 0x672 <Command+0x3a>
 654:	18 f4       	brcc	.+6      	; 0x65c <Command+0x24>
 656:	81 36       	cpi	r24, 0x61	; 97
 658:	49 f0       	breq	.+18     	; 0x66c <Command+0x34>
 65a:	10 c0       	rjmp	.+32     	; 0x67c <Command+0x44>
 65c:	8c 36       	cpi	r24, 0x6C	; 108
 65e:	19 f0       	breq	.+6      	; 0x666 <Command+0x2e>
 660:	85 37       	cpi	r24, 0x75	; 117
 662:	51 f0       	breq	.+20     	; 0x678 <Command+0x40>
 664:	0b c0       	rjmp	.+22     	; 0x67c <Command+0x44>
	{
		case 'L' | 'l': LCD();
 666:	0e 94 7f 01 	call	0x2fe	; 0x2fe <LCD>
		break;
 66a:	08 95       	ret
		case 'A' | 'a': ADC();
 66c:	0e 94 9d 01 	call	0x33a	; 0x33a <ADC>
		break;
 670:	08 95       	ret
		case 'E' | 'e': EEPROM();
 672:	0e 94 f5 01 	call	0x3ea	; 0x3ea <EEPROM>
		break;
 676:	08 95       	ret
		case 'U' | 'u': USART();
 678:	0e 94 03 03 	call	0x606	; 0x606 <USART>
		default:
		UART_Puts(MS5);
 67c:	8c ef       	ldi	r24, 0xFC	; 252
 67e:	94 e0       	ldi	r25, 0x04	; 4
 680:	0e 94 4b 01 	call	0x296	; 0x296 <UART_Puts>
		HELP();
 684:	0e 94 7a 01 	call	0x2f4	; 0x2f4 <HELP>
 688:	08 95       	ret

0000068a <main>:
	}
}

int main(void)
{
	Mega328P_Init();
 68a:	0e 94 79 00 	call	0xf2	; 0xf2 <Mega328P_Init>
	Banner();
 68e:	0e 94 6d 01 	call	0x2da	; 0x2da <Banner>
	while (1)
	{
		Command();				//infinite command loop
 692:	0e 94 1c 03 	call	0x638	; 0x638 <Command>
 696:	fd cf       	rjmp	.-6      	; 0x692 <main+0x8>

00000698 <__divmodhi4>:
 698:	97 fb       	bst	r25, 7
 69a:	07 2e       	mov	r0, r23
 69c:	16 f4       	brtc	.+4      	; 0x6a2 <__divmodhi4+0xa>
 69e:	00 94       	com	r0
 6a0:	07 d0       	rcall	.+14     	; 0x6b0 <__divmodhi4_neg1>
 6a2:	77 fd       	sbrc	r23, 7
 6a4:	09 d0       	rcall	.+18     	; 0x6b8 <__divmodhi4_neg2>
 6a6:	0e 94 60 03 	call	0x6c0	; 0x6c0 <__udivmodhi4>
 6aa:	07 fc       	sbrc	r0, 7
 6ac:	05 d0       	rcall	.+10     	; 0x6b8 <__divmodhi4_neg2>
 6ae:	3e f4       	brtc	.+14     	; 0x6be <__divmodhi4_exit>

000006b0 <__divmodhi4_neg1>:
 6b0:	90 95       	com	r25
 6b2:	81 95       	neg	r24
 6b4:	9f 4f       	sbci	r25, 0xFF	; 255
 6b6:	08 95       	ret

000006b8 <__divmodhi4_neg2>:
 6b8:	70 95       	com	r23
 6ba:	61 95       	neg	r22
 6bc:	7f 4f       	sbci	r23, 0xFF	; 255

000006be <__divmodhi4_exit>:
 6be:	08 95       	ret

000006c0 <__udivmodhi4>:
 6c0:	aa 1b       	sub	r26, r26
 6c2:	bb 1b       	sub	r27, r27
 6c4:	51 e1       	ldi	r21, 0x11	; 17
 6c6:	07 c0       	rjmp	.+14     	; 0x6d6 <__udivmodhi4_ep>

000006c8 <__udivmodhi4_loop>:
 6c8:	aa 1f       	adc	r26, r26
 6ca:	bb 1f       	adc	r27, r27
 6cc:	a6 17       	cp	r26, r22
 6ce:	b7 07       	cpc	r27, r23
 6d0:	10 f0       	brcs	.+4      	; 0x6d6 <__udivmodhi4_ep>
 6d2:	a6 1b       	sub	r26, r22
 6d4:	b7 0b       	sbc	r27, r23

000006d6 <__udivmodhi4_ep>:
 6d6:	88 1f       	adc	r24, r24
 6d8:	99 1f       	adc	r25, r25
 6da:	5a 95       	dec	r21
 6dc:	a9 f7       	brne	.-22     	; 0x6c8 <__udivmodhi4_loop>
 6de:	80 95       	com	r24
 6e0:	90 95       	com	r25
 6e2:	bc 01       	movw	r22, r24
 6e4:	cd 01       	movw	r24, r26
 6e6:	08 95       	ret

000006e8 <_exit>:
 6e8:	f8 94       	cli

000006ea <__stop_program>:
 6ea:	ff cf       	rjmp	.-2      	; 0x6ea <__stop_program>
